<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Imajination Garden</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        canvas {
            display: block;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 12px;
            display: flex;
            gap: 15px;
            opacity: 1;
            z-index: 100;
        }

        button {
            padding: 12px 24px;
            cursor: pointer;
            background: #4A90E2;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            transition: background 0.2s;
        }

        button:hover {
            background: #357ABD;
        }

        #next-btn {
            background: #27ae60;
        }

        #next-btn:hover {
            background: #1e8449;
        }

        #reset-btn {
            background: #e74c3c;
        }

        #reset-btn:hover {
            background: #c0392b;
        }

        .hud {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            text-align: right;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }

        h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        p {
            margin: 5px 0 0;
        }
    </style>
</head>

<body>

    <canvas id="gardenCanvas"></canvas>

    <div class="hud">
        <h2 id="stage-name">Stage 1: Base</h2>
        <p id="stats">Avg Health: -%</p>
    </div>

    <div id="controls">
        <button id="next-btn" onclick="nextQuestion()">Next Question &#10132;</button>
        <button id="reset-btn" onclick="resetGarden()">Reset Garden</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Supabase Config
        const SUPABASE_URL = 'https://uxyojsfbpvugnudbhwhb.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV4eW9qc2ZicHZ1Z251ZGJod2hiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg4OTI0NjgsImV4cCI6MjA4NDQ2ODQ2OH0.p8uP0jHpEvsblAR--oSST5rSAXkhM3-MgRvQTsxv_r0';
        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        const canvas = document.getElementById('gardenCanvas');
        const ctx = canvas.getContext('2d');

        // Game State (must be defined before resize/animate)
        let currentQuestionIndex = 0;
        let gardenState = new Array(10).fill(50);
        let voteCounts = new Array(10).fill(0);
        let rawAnswers = Array.from({ length: 10 }, () => []);

        // Smooth transition targets
        let displayState = new Array(10).fill(0); // What's actually displayed (for smooth transitions)
        let targetState = new Array(10).fill(0);  // Target values to animate towards

        const stageNames = [
            "Pijakan", "Langit", "Pohon", "Bunga", "Air",
            "Kunang-kunang", "Matahari", "Angin", "Akar", "Buah"
        ];

        // Animation state
        let frame = 0;
        let pulseIntensity = 0; // For vote pulse effect
        let lastVoteTime = 0;

        // Procedural generation seeds (stable per session)
        const treeSeed = Math.random() * 1000;
        const flowerSeed = Math.random() * 1000;

        // Pseudo-random function with seed
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // Setup Canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize(); // Call immediately on load

        // Start animation after drawGarden is defined (moved to bottom)

        // --- Supabase Logic ---

        async function init() {
            // 1. Get Game State
            const { data: gsData } = await supabaseClient
                .from('game_state')
                .select('current_question_index')
                .eq('id', 1)
                .single();
            if (gsData) {
                currentQuestionIndex = gsData.current_question_index;
            }

            // 2. Fetch ALL answers to build initial state (Heavy initial load, ok for <10k rows)
            const { data: allAnswers } = await supabaseClient.from('answers').select('question_index, value');

            if (allAnswers) {
                allAnswers.forEach(ans => {
                    if (ans.question_index < 10) {
                        rawAnswers[ans.question_index].push(ans.value);
                    }
                });
                recalcAll();
            }

            updateHUD();

            // 3. Listen for NEW answers
            supabaseClient
                .channel('room1')
                .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'answers' }, payload => {
                    const newAns = payload.new;
                    if (newAns.question_index < 10) {
                        rawAnswers[newAns.question_index].push(newAns.value);
                        recalc(newAns.question_index, true); // Trigger pulse!
                        updateHUD();
                    }
                })
                .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'game_state' }, payload => {
                    currentQuestionIndex = payload.new.current_question_index;
                    updateHUD();
                })
                .subscribe();
        }

        function recalc(index, triggerPulse = false) {
            const arr = rawAnswers[index];
            if (arr.length > 0) {
                const sum = arr.reduce((a, b) => a + b, 0);
                gardenState[index] = sum / arr.length;
                targetState[index] = gardenState[index];
                voteCounts[index] = arr.length;
            } else {
                gardenState[index] = 0;
                targetState[index] = 0;
                voteCounts[index] = 0;
            }

            // Trigger pulse effect when new vote comes in
            if (triggerPulse) {
                pulseIntensity = 1.0;
                lastVoteTime = frame;
            }
        }

        function recalcAll() {
            for (let i = 0; i < 10; i++) recalc(i, false);
        }

        // Smooth interpolation for display values
        function updateDisplayState() {
            for (let i = 0; i < 10; i++) {
                const target = hasVotes(i) ? targetState[i] : 0;
                // Smooth easing towards target
                displayState[i] += (target - displayState[i]) * 0.05;
            }
            // Decay pulse effect
            pulseIntensity *= 0.95;
        }

        function updateHUD() {
            const currentAvg = Math.round(gardenState[currentQuestionIndex] || 0);
            const count = voteCounts[currentQuestionIndex] || 0;

            document.getElementById('stage-name').innerText = `Stage ${currentQuestionIndex + 1}: ${stageNames[currentQuestionIndex]}`;

            let text = `Avg Health: ${currentAvg}%`;
            // Show vote count
            text += ` | Votes: ${count}`;

            document.getElementById('stats').innerText = text;
        }

        // --- HOST CONTROL FUNCTIONS ---

        async function nextQuestion() {
            if (currentQuestionIndex >= 9) {
                alert('Sudah di pertanyaan terakhir!');
                return;
            }

            const newIndex = currentQuestionIndex + 1;
            const { error } = await supabaseClient
                .from('game_state')
                .update({ current_question_index: newIndex })
                .eq('id', 1);

            if (error) {
                console.error('Error advancing question:', error);
                alert('Gagal pindah pertanyaan');
            } else {
                currentQuestionIndex = newIndex;
                updateHUD();
            }
        }

        async function resetGarden() {
            if (!confirm('Yakin ingin reset garden? Semua jawaban akan dihapus.')) return;

            // Reset game state to question 0
            const { error: stateError } = await supabaseClient
                .from('game_state')
                .update({ current_question_index: 0 })
                .eq('id', 1);

            // Delete all answers
            const { error: answersError } = await supabaseClient
                .from('answers')
                .delete()
                .gte('id', 0);

            if (stateError || answersError) {
                console.error('Error resetting:', stateError || answersError);
                alert('Gagal reset garden');
            } else {
                // Reset local state
                currentQuestionIndex = 0;
                gardenState = new Array(10).fill(50);
                voteCounts = new Array(10).fill(0);
                rawAnswers = Array.from({ length: 10 }, () => []);
                updateHUD();
            }
        }

        // --- VISUALIZATION LOGIC ---

        // Helper: check if stage has votes
        function hasVotes(stageIndex) {
            return voteCounts[stageIndex] > 0;
        }

        // Calculate overall mood (average of all answered questions)
        function getOverallMood() {
            let sum = 0, count = 0;
            for (let i = 0; i <= currentQuestionIndex; i++) {
                if (hasVotes(i)) {
                    sum += displayState[i];
                    count++;
                }
            }
            return count > 0 ? sum / count : 30;
        }

        // Color interpolation helper
        function lerpColor(color1, color2, t) {
            const r = Math.round(color1[0] + (color2[0] - color1[0]) * t);
            const g = Math.round(color1[1] + (color2[1] - color1[1]) * t);
            const b = Math.round(color1[2] + (color2[2] - color1[2]) * t);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Get mood-based sky colors
        function getMoodColors(mood) {
            const h = mood / 100;
            if (h < 0.3) {
                // Low: contemplative purple/twilight
                return {
                    skyTop: [45, 27, 62],      // Deep purple
                    skyBottom: [89, 61, 99],   // Soft violet
                    ambient: [147, 112, 219]   // Medium purple
                };
            } else if (h < 0.6) {
                // Medium: calm blue/teal
                return {
                    skyTop: [70, 130, 180],    // Steel blue
                    skyBottom: [135, 206, 235], // Sky blue
                    ambient: [100, 149, 237]   // Cornflower
                };
            } else {
                // High: warm golden/energetic
                return {
                    skyTop: [135, 206, 250],   // Light sky blue
                    skyBottom: [255, 223, 186], // Peach
                    ambient: [255, 215, 0]     // Gold
                };
            }
        }

        function drawGarden() {
            // Update smooth transitions
            updateDisplayState();

            const mood = getOverallMood();
            const colors = getMoodColors(mood);

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw layers in order
            drawSky(displayState[1], mood, colors);
            drawTerrain(displayState[0], mood);

            // Draw grass (ambient motion)
            drawGrass(mood);

            // 9. Roots - behind trees
            if (currentQuestionIndex >= 8 && displayState[8] > 1) {
                drawRoots(displayState[8]);
            }

            // 3. Trees
            if (currentQuestionIndex >= 2 && displayState[2] > 1) {
                drawTrees(displayState[2]);
            }

            // 5. Water
            if (currentQuestionIndex >= 4 && displayState[4] > 1) {
                drawWater(displayState[4]);
            }

            // 4. Flowers
            if (currentQuestionIndex >= 3 && displayState[3] > 1) {
                drawFlowers(displayState[3]);
            }

            // 6. Fireflies
            if (currentQuestionIndex >= 5 && displayState[5] > 1) {
                drawFauna(displayState[5], colors);
            }

            // 7. Sun
            if (currentQuestionIndex >= 6 && displayState[6] > 1) {
                drawSun(displayState[6], colors);
            }

            // 8. Wind particles
            if (currentQuestionIndex >= 7 && displayState[7] > 1) {
                drawWind(displayState[7]);
            }

            // 10. Fruits
            if (currentQuestionIndex >= 9 && displayState[9] > 1) {
                drawFruits(displayState[9]);
            }

            // Draw pulse overlay effect
            if (pulseIntensity > 0.01) {
                drawPulseEffect();
            }
        }

        // --- DRAWING FUNCTIONS ---

        // Pulse effect when new vote arrives
        function drawPulseEffect() {
            const alpha = pulseIntensity * 0.3;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Ambient grass with wind sway
        function drawGrass(mood) {
            const groundY = canvas.height * 0.6;
            const grassCount = Math.floor(canvas.width / 8);
            const time = frame * 0.02;
            const h = mood / 100;

            for (let i = 0; i < grassCount; i++) {
                const x = (i * 8) + seededRandom(i * 13) * 5;
                const height = 15 + seededRandom(i * 7) * 20 * h;
                const sway = Math.sin(time + i * 0.3) * 3 * (1 + h);

                // Color varies with mood
                const green = Math.floor(100 + h * 80 + seededRandom(i) * 30);
                ctx.strokeStyle = `rgb(${50 - h * 20}, ${green}, ${30})`;
                ctx.lineWidth = 1;

                ctx.beginPath();
                ctx.moveTo(x, groundY);
                ctx.quadraticCurveTo(x + sway * 0.5, groundY - height * 0.6, x + sway, groundY - height);
                ctx.stroke();
            }
        }

        function drawTerrain(health, mood) {
            const h = Math.max(health, 10) / 100;
            const groundY = canvas.height * 0.6;

            // Create rolling hills with bezier curves
            const gradient = ctx.createLinearGradient(0, groundY, 0, canvas.height);

            // Color based on mood
            if (mood < 30) {
                gradient.addColorStop(0, `rgb(${80 + h * 40}, ${60 + h * 30}, ${50})`);
                gradient.addColorStop(1, `rgb(${40}, ${30}, ${25})`);
            } else if (mood < 60) {
                gradient.addColorStop(0, `rgb(${60 + h * 20}, ${100 + h * 50}, ${40})`);
                gradient.addColorStop(1, `rgb(${30}, ${50}, ${20})`);
            } else {
                gradient.addColorStop(0, `rgb(${34 + h * 30}, ${139 + h * 30}, ${34})`);
                gradient.addColorStop(1, `rgb(${20}, ${80}, ${20})`);
            }

            // Draw hilly terrain
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, groundY);

            // Create gentle hills
            for (let x = 0; x <= canvas.width; x += 50) {
                const hillHeight = Math.sin(x * 0.005 + treeSeed) * 20 * h;
                ctx.lineTo(x, groundY + hillHeight);
            }

            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        function drawSky(health, mood, colors) {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.65);
            gradient.addColorStop(0, `rgb(${colors.skyTop[0]}, ${colors.skyTop[1]}, ${colors.skyTop[2]})`);
            gradient.addColorStop(1, `rgb(${colors.skyBottom[0]}, ${colors.skyBottom[1]}, ${colors.skyBottom[2]})`);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height * 0.65);

            // Animated clouds
            const h = mood / 100;
            if (h > 0.3) {
                const cloudOpacity = 0.2 + h * 0.4;
                ctx.fillStyle = `rgba(255, 255, 255, ${cloudOpacity})`;
                const t = frame * 0.0003;

                for (let i = 0; i < 6; i++) {
                    const seed = seededRandom(i * 100 + treeSeed);
                    const x = ((seed * canvas.width + t * canvas.width * (0.5 + seed)) % (canvas.width + 300)) - 150;
                    const y = 40 + seed * 100;
                    const size = 30 + seed * 40;

                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.arc(x + size * 0.8, y - size * 0.2, size * 1.2, 0, Math.PI * 2);
                    ctx.arc(x + size * 1.6, y + size * 0.1, size * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Stars for low mood (twilight)
            if (mood < 35) {
                const starCount = Math.floor((35 - mood) * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < starCount; i++) {
                    const x = seededRandom(i * 17) * canvas.width;
                    const y = seededRandom(i * 23) * canvas.height * 0.4;
                    const twinkle = 0.5 + Math.sin(frame * 0.05 + i) * 0.5;
                    ctx.globalAlpha = twinkle;
                    ctx.beginPath();
                    ctx.arc(x, y, 1 + seededRandom(i) * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
        }

        // L-System inspired procedural tree
        function drawProceduralBranch(x, y, len, angle, width, depth, health, seed) {
            if (depth < 0 || len < 2) return;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            // Sway animation
            const sway = Math.sin(frame * 0.008 + seed + depth * 0.5) * 0.03 * (5 - depth);
            ctx.rotate(sway);

            // Branch color
            const h = health / 100;
            ctx.strokeStyle = `rgb(${60 + h * 30}, ${40 + h * 20}, ${30})`;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -len);
            ctx.stroke();

            if (depth > 0) {
                // Procedural branching with variation
                const branchFactor = 0.65 + h * 0.15;
                const angleVar = 0.3 + seededRandom(seed + depth) * 0.2;

                // Left branch
                const leftAngle = -angleVar + seededRandom(seed * 2 + depth) * 0.1;
                drawProceduralBranch(0, -len, len * branchFactor, leftAngle, width * 0.7, depth - 1, health, seed + 1);

                // Right branch
                const rightAngle = angleVar + seededRandom(seed * 3 + depth) * 0.1;
                drawProceduralBranch(0, -len, len * branchFactor, rightAngle, width * 0.7, depth - 1, health, seed + 2);

                // Sometimes add middle branch for fuller trees
                if (h > 0.5 && seededRandom(seed + depth * 7) > 0.6) {
                    drawProceduralBranch(0, -len * 0.7, len * branchFactor * 0.8, seededRandom(seed) * 0.2 - 0.1, width * 0.5, depth - 2, health, seed + 3);
                }
            } else {
                // Leaves at branch tips
                if (health > 15) {
                    const leafSize = 4 + h * 8 + pulseIntensity * 3;
                    const leafHue = 80 + h * 40; // Yellow-green to deep green

                    ctx.fillStyle = `hsla(${leafHue}, ${50 + h * 30}%, ${30 + h * 25}%, 0.85)`;
                    ctx.beginPath();
                    ctx.arc(0, -len, leafSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawTrees(health) {
            const h = health / 100;
            const treeCount = 3 + Math.floor(h * 4);

            for (let i = 0; i < treeCount; i++) {
                const seed = treeSeed + i * 100;
                const treeX = canvas.width * (0.1 + (i / treeCount) * 0.8) + seededRandom(seed) * 60 - 30;
                const treeY = canvas.height * 0.6 + seededRandom(seed + 1) * 30;
                const treeHeight = 50 + h * 80 + seededRandom(seed + 2) * 40;
                const treeWidth = 6 + h * 8;
                const depth = 3 + Math.floor(h * 3);

                drawProceduralBranch(treeX, treeY, treeHeight, 0, treeWidth, depth, health, seed);
            }
        }

        function drawFlowers(health) {
            const h = health / 100;
            const count = Math.floor(h * 40);
            const time = frame * 0.03;

            for (let i = 0; i < count; i++) {
                const seed = flowerSeed + i * 37;
                const x = seededRandom(seed) * canvas.width;
                const y = canvas.height * 0.62 + seededRandom(seed + 1) * canvas.height * 0.35;

                // Skip if in water area
                if (y > canvas.height * 0.83) continue;

                const stemHeight = 15 + seededRandom(seed + 2) * 20;
                const sway = Math.sin(time + x * 0.01 + seededRandom(seed) * 3) * 4;

                // Stem
                ctx.strokeStyle = `rgb(${40 + h * 30}, ${100 + h * 50}, ${30})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + sway * 0.5, y - stemHeight * 0.5, x + sway, y - stemHeight);
                ctx.stroke();

                // Flower head
                const hue = seededRandom(seed + 3) * 60 + (h > 0.5 ? 300 : 30); // Purples/pinks or yellows
                const size = 3 + h * 5 + pulseIntensity * 2;
                ctx.fillStyle = `hsl(${hue}, 70%, ${50 + h * 20}%)`;
                ctx.beginPath();
                ctx.arc(x + sway, y - stemHeight, size, 0, Math.PI * 2);
                ctx.fill();

                // Flower center
                ctx.fillStyle = `hsl(${hue + 40}, 80%, 70%)`;
                ctx.beginPath();
                ctx.arc(x + sway, y - stemHeight, size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawWater(health) {
            const h = health / 100;
            const time = frame * 0.015;
            const yBase = canvas.height * 0.85;

            // Water gradient
            const gradient = ctx.createLinearGradient(0, yBase, 0, canvas.height);
            gradient.addColorStop(0, `rgba(100, 180, 255, ${0.4 + h * 0.3})`);
            gradient.addColorStop(1, `rgba(30, 100, 180, ${0.6 + h * 0.2})`);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, yBase);

            // Smooth waves
            for (let x = 0; x <= canvas.width; x += 10) {
                const wave1 = Math.sin(x * 0.02 + time) * 8 * h;
                const wave2 = Math.sin(x * 0.01 + time * 0.7) * 5 * h;
                ctx.lineTo(x, yBase + wave1 + wave2);
            }

            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();

            // Shimmer/reflections
            ctx.fillStyle = `rgba(255, 255, 255, ${0.1 + h * 0.15})`;
            for (let i = 0; i < 8; i++) {
                const rx = seededRandom(i * 50) * canvas.width;
                const ry = yBase + 20 + seededRandom(i * 51) * (canvas.height - yBase - 30);
                const rw = 20 + seededRandom(i * 52) * 40;
                const shimmer = 0.5 + Math.sin(time * 2 + i) * 0.5;

                ctx.globalAlpha = shimmer * (0.1 + h * 0.2);
                ctx.fillRect(rx, ry, rw, 2);
            }
            ctx.globalAlpha = 1;
        }

        function drawFauna(health, colors) {
            const h = health / 100;
            const count = Math.floor(h * 15);

            for (let i = 0; i < count; i++) {
                const t = frame * 0.008 + i * 0.7;
                const seed = seededRandom(i * 67);

                // Organic floating movement
                const baseX = seed * canvas.width;
                const baseY = 0.2 + seed * 0.5;
                const x = baseX + Math.sin(t + seed * 10) * 100;
                const y = baseY * canvas.height + Math.cos(t * 0.8 + seed * 5) * 50;

                // Glow effect
                const glow = 0.5 + Math.sin(t * 3) * 0.5;
                const size = 2 + glow * 3 + pulseIntensity * 2;

                // Color from mood
                ctx.fillStyle = `rgba(${colors.ambient[0]}, ${colors.ambient[1]}, ${colors.ambient[2]}, ${0.6 + glow * 0.4})`;

                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();

                // Outer glow
                ctx.fillStyle = `rgba(${colors.ambient[0]}, ${colors.ambient[1]}, ${colors.ambient[2]}, ${0.1 + glow * 0.1})`;
                ctx.beginPath();
                ctx.arc(x, y, size * 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawSun(health, colors) {
            const h = health / 100;
            const x = canvas.width * 0.85;
            const y = canvas.height * 0.12;
            const baseSize = 30 + h * 40;

            // Animated rays
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(frame * 0.002);

            const rayCount = 12;
            for (let i = 0; i < rayCount; i++) {
                ctx.rotate(Math.PI * 2 / rayCount);
                const rayLength = baseSize + Math.sin(frame * 0.02 + i) * 20;

                ctx.strokeStyle = `rgba(${colors.ambient[0]}, ${colors.ambient[1]}, ${colors.ambient[2]}, ${0.15 + h * 0.1})`;
                ctx.lineWidth = 3 + h * 3;
                ctx.beginPath();
                ctx.moveTo(baseSize * 0.5, 0);
                ctx.lineTo(rayLength * 1.5, 0);
                ctx.stroke();
            }
            ctx.restore();

            // Sun glow
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, baseSize * 3);
            gradient.addColorStop(0, `rgba(255, 250, 220, ${0.8 + h * 0.2})`);
            gradient.addColorStop(0.3, `rgba(${colors.ambient[0]}, ${colors.ambient[1]}, ${colors.ambient[2]}, ${0.4 + h * 0.2})`);
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, baseSize * 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';

            // Sun core
            ctx.fillStyle = `rgba(255, 250, 230, ${0.9 + pulseIntensity * 0.1})`;
            ctx.beginPath();
            ctx.arc(x, y, baseSize * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawWind(health) {
            const h = health / 100;
            const particleCount = Math.floor(h * 20);

            ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 + h * 0.15})`;
            ctx.lineWidth = 1;

            for (let i = 0; i < particleCount; i++) {
                const seed = seededRandom(i * 89);
                const speed = 2 + seed * 3;
                const x = ((frame * speed + seed * canvas.width) % (canvas.width + 200)) - 100;
                const y = seed * canvas.height * 0.7 + Math.sin(frame * 0.02 + i) * 30;
                const length = 30 + seed * 50;

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + length * 0.5, y - 5 + Math.sin(frame * 0.05 + i) * 3, x + length, y);
                ctx.stroke();
            }
        }

        function drawRoots(health) {
            const h = health / 100;
            const groundY = canvas.height * 0.6;

            ctx.strokeStyle = `rgba(60, 40, 30, ${0.3 + h * 0.4})`;
            ctx.lineWidth = 2 + h * 2;
            ctx.lineCap = 'round';

            const rootCount = 5 + Math.floor(h * 5);
            for (let i = 0; i < rootCount; i++) {
                const seed = treeSeed + i * 200;
                const startX = seededRandom(seed) * canvas.width;
                const depth = 50 + seededRandom(seed + 1) * 100 * h;

                ctx.beginPath();
                ctx.moveTo(startX, groundY);

                // Organic root path
                let x = startX;
                let y = groundY;
                for (let j = 0; j < 5; j++) {
                    const dx = (seededRandom(seed + j * 10) - 0.5) * 60;
                    const dy = depth / 5;
                    x += dx;
                    y += dy;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        function drawFruits(health) {
            const h = health / 100;
            if (h < 0.3) return;

            const treeCount = 3 + Math.floor(displayState[2] / 100 * 4);

            for (let i = 0; i < treeCount; i++) {
                const seed = treeSeed + i * 100;
                const treeX = canvas.width * (0.1 + (i / treeCount) * 0.8) + seededRandom(seed) * 60 - 30;
                const treeY = canvas.height * 0.6;
                const treeHeight = 50 + (displayState[2] / 100) * 80;

                const fruitCount = Math.floor(h * 5);
                for (let j = 0; j < fruitCount; j++) {
                    const fseed = seed + j * 30;
                    const angle = seededRandom(fseed) * Math.PI - Math.PI / 2;
                    const dist = 30 + seededRandom(fseed + 1) * 50;
                    const fx = treeX + Math.cos(angle) * dist;
                    const fy = treeY - treeHeight * 0.7 + Math.sin(angle) * dist * 0.5;

                    // Gentle sway
                    const sway = Math.sin(frame * 0.02 + fseed) * 3;

                    // Fruit
                    const size = 5 + h * 5 + pulseIntensity * 2;
                    const gradient = ctx.createRadialGradient(fx + sway, fy, 0, fx + sway, fy, size);
                    gradient.addColorStop(0, '#ff6b6b');
                    gradient.addColorStop(0.7, '#ee5a5a');
                    gradient.addColorStop(1, '#cc4444');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(fx + sway, fy, size, 0, Math.PI * 2);
                    ctx.fill();

                    // Highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(fx + sway - size * 0.3, fy - size * 0.3, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // --- START APPLICATION ---
        // Animation loop (must be after drawGarden is defined)
        function animate() {
            frame++;
            drawGarden();
            requestAnimationFrame(animate);
        }

        // Initialize and start
        init();
        updateHUD();
        animate();
    </script>
</body>

</html>